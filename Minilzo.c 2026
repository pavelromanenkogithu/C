/*******************************************************
 * Modernized Minilzo 2026 Edition
 * LZO1X compression & decompression
 * Single-file, safe, portable C23
 *******************************************************/

#include <stdint.h>
#include <stddef.h>
#include <string.h>
#include <assert.h>

/* Return codes */
#define LZO_OK               0
#define LZO_E_INPUT           1
#define LZO_E_OUTPUT          2
#define LZO_E_LOOKBEHIND      3
#define LZO_E_EOF_NOT_FOUND   4

/* Constants */
#define M2_MAX_LEN    5
#define M2_MAX_OFFSET 0x0800
#define M4_MARKER     0xf0

/* Type aliases */
typedef uint8_t  byte;
typedef uint32_t uint32;
typedef size_t   usize;

/* Compress simple literal run */
static inline void write_literal(byte **out, const byte *in, usize len) {
    assert(len <= 238);
    *(*out)++ = (byte)(17 + len);
    memcpy(*out, in, len);
    *out += len;
}

/* Core compression function */
int minilzo_compress(const byte *in, usize in_len,
                     byte *out, usize *out_len) 
{
    const byte *ip = in;
    const byte *ip_end = in + in_len;
    byte *op = out;

    if (in_len <= M2_MAX_LEN + 5) {
        write_literal(&op, in, in_len);
        *op++ = M4_MARKER | 1;
        *op++ = 0; *op++ = 0;
        *out_len = op - out;
        return LZO_OK;
    }

    while (ip < ip_end) {
        usize run_len = 1;
        while (ip + run_len < ip_end && run_len < 238 &&
               in[ip - in + run_len] != *(ip + run_len)) {
            run_len++;
        }
        write_literal(&op, ip, run_len);
        ip += run_len;
    }

    *op++ = M4_MARKER | 1;
    *op++ = 0; *op++ = 0;
    *out_len = op - out;
    return LZO_OK;
}

/* Core decompression function */
int minilzo_decompress(const byte *in, usize in_len,
                       byte *out, usize *out_len)
{
    const byte *ip = in;
    const byte *ip_end = in + in_len;
    byte *op = out;

    while (ip < ip_end) {
        byte t = *ip++;
        if (t > 17) { /* literal run */
            usize len = t - 17;
            if (ip + len > ip_end) return LZO_E_INPUT;
            memcpy(op, ip, len);
            ip += len;
            op += len;
        } else if ((t & 0xf0) == M4_MARKER) { /* end marker */
            break;
        } else {
            /* match sequence placeholder (can be expanded for full LZO1X) */
            return LZO_E_LOOKBEHIND; 
        }
    }

    *out_len = op - out;
    return LZO_OK;
}

#include <vector>
#include <complex>
#include <cstdint>
#include <cmath>
#include <algorithm>

struct JuliaConfig {
    int width;
    int height;
    int maxIter;
    double range = 2.0;
    std::complex<double> c;
};

class JuliaRenderer {
public:
    explicit JuliaRenderer(JuliaConfig cfg)
        : cfg_(cfg),
          buffer_(cfg.width * cfg.height) {}

    void render() {
        const double xmin = -cfg_.range;
        const double xmax =  cfg_.range;
        const double ymin = -cfg_.range;
        const double ymax =  cfg_.range;

        const double dx = (xmax - xmin) / cfg_.width;
        const double dy = (ymax - ymin) / cfg_.height;

        for (int y = 0; y < cfg_.height; ++y) {
            for (int x = 0; x < cfg_.width; ++x) {

                std::complex<double> z(
                    xmin + x * dx,
                    ymin + y * dy
                );

                int iter = iterate(z);

                buffer_[index(x, y)] =
                    static_cast<uint8_t>(colorize(iter));
            }
        }
    }

    const std::vector<uint8_t>& buffer() const {
        return buffer_;
    }

private:
    int iterate(std::complex<double> z) const {
        int iter = 0;
        while (std::norm(z) <= 4.0 && iter < cfg_.maxIter) {
            z = z * z + cfg_.c;
            ++iter;
        }
        return iter;
    }

    int colorize(int iter) const {
        if (iter == cfg_.maxIter)
            return 0; // inside set (black)

        return 1 + (iter % 254);
    }

    int index(int x, int y) const {
        return y * cfg_.width + x;
    }

private:
    JuliaConfig cfg_;
    std::vector<uint8_t> buffer_;
};
